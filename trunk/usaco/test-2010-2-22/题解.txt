graph：最短路+最大流
从 A 到 B 做最短路。
一条边 (a, b) 是最短路径上的边的条件是：D[a] + w(a, b) == D[b]
删去其他所有非最短路径边，得到最短路径图。
图中所有边容量设为 1，求 A 到 B 的最大流，即为答案。
注意重边的处理。另外点数较多，尽量采用 dijkstra/spfa + dinic。

matrix：贪心/分类讨论
这是一道看起来很简单的题，事实上需要做比较麻烦的分类讨论。
主要思想是对矩阵 A 通过变换“造”出一个不对称对，这样其他的元素可以任意变换，
最终“修复”这个不对称对完成转换到 B。
我们设 A 和 B 不同元素的个数为 S，我们最少需要 S 步操作。

首先我们假设 K > 2 开始讨论。
如果 B 是一个对称矩阵，那么无解。否则 B 中一定存在一个不对称对，
即存在 i, j 满足 Bij != Bji。

这时，如果 Aij == Bij 且 Aji == Bji，那么 Aij 和 Aji 本身就是一个不对称对，
于是 A 所有其他元素可以做任意变换，得答案为 S。其他还有 3 种情况：
1. 如果 Aij == Bij 和 Aji == Bji 只有一个满足，可以将不满足的那一个变成跟 B 对应元素一样，
再任意变换其他元素，答案仍然为 S。
2. 如果不是满足 Aij == Bji 且 Aji == Bij 的情况，
可以先令 Aij = Bij，必有 Aij != Aji，再做变换，最终答案为 S。

3. 现讨论最复杂的，Aij == Bji 且 Aji == Bij 的情况。
如果我们必须使用这两个元素构造不对称对，那么答案将是 S + 1，多了 1 步。
为了减小答案到 S，我们必须造出其他不对称对。注意此时造出的其他不对称对可以是临时的。
有如下方法：
(1) A 中直接存在其他一个不对称对。
(2) 存在 Aij == Aji，Bij == Bji，但是 Aij != Bij，
这样子我们可以先把 Aij 变成 Bij，成为一个临时不对称对。
(3) 假设 B 中还有其他不对称对，由于有了当前这个不对称对的存在，
我们可以先把 A 中对应的那两个元素变成正确的不对称对。
(4) 最坏的情况就是 A 和 B 中都没有其他的不对称对，且 A 的其他元素全部和 B 中对应元素一样
这样必须需要 S + 1 步。

现在讨论 K = 2 的情况。
这种情况与 K > 2 的不同之处在于，如果出现上述情况 3 (4)，Aij = 1，Aji = 2，Bij = 2，Bji = 1，
我们没有办法单独将这个不对称对变换，这时我们被迫需要将其他一个正常的一样的不对称对，
破坏其中一个造出一个不对称对，等当前的不对称对构造好了以后恢复。这样结果就是 S + 2。
这种情况下如果元素总共只有 2 * 2，那么显然无解。

将上述所有思想归纳、整理，就可以得到最终程序。

ring：数据结构/DP
由于是个环，先展开成链，即令 A[N + i] = A[i] (i < N)
然后求串 A[1..N * 2 - 1] 上的最大和。

数据结构方法：
设部分和 S[i] = A[1] + A[2] + .. + A[i]
有 S(i, j) = A[i] + A[i + 1] + .. + A[j] = S[j] - S[i - 1]
而我们要求出满足 j - (i - 1) <= K 的最大 S(i, j)。
我们固定 i - 1，这样有 j 属于 [i, i + K - 1]
由于 i - 1 固定，所以 S[i - 1] 固定，那么要让 S(i, j) 最大即 S[j] 最大
这就变成了求数组 S 在区间 [i, i + K - 1] 内的最大值问题，即经典的 RMQ 问题
这个问题可以通过线段树在 O(NlgN) 时间预处理后在 O(lgN) 时间内回答。
于是我们循环扫描起始点 i，每步用 O(lgK) 时间求出从 i 开始的长度不超过 K 的区间最大和
最终复杂度 O(NlgN)

附：也可以采用 Sparse Table 算法，最终复杂度为 O(NlgK) 或 O(N)。

也可以使用 DP + 单调队列优化，总复杂度为 O(N)。

robot：BFS/DP
注意到能量池+开关个数<=15。
以当前位置、能量池是否使用、开关是否打开为状态做反向或正向 BFS/DP/记忆化搜索。
状态数上限 15 * 15 * 2^15，由于大部分状态实际上是达不到的，所以这样的程序可以很快出解。
