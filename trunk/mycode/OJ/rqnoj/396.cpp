#include <iostream>
using namespace std;
int main(){
    short i,j,n,m,a[1000][1000],Max=-2,left,above;
    bool b[2][1000];
    cin>>n>>m;
    for(i=0;i<n;i++)
        for(j=0;j<m;j++){
            cin>>a[i][j];
            b[i][j]=0;
        }
    for(i=0;i<n;i++){
        for(j=0;j<m;j++){
            if(a[i][j]!=-1){
                left=above=0;
                if(i-1>=0 && j-2>=0) if(a[i-1][j-2]!=-1) {left=a[i-1][j-2]; if(j==m-1)b[0][j]=1;if(i==n-1)b[1][i]=1;}
                if(i-2>=0 && j-1>=0) if(a[i-2][j-1]!=-1) {above=a[i-2][j-1]; if(j==m-1)b[0][j]=1;if(i==n-1)b[1][i]=1;}
                if(left>above) a[i][j]+=left;
                else a[i][j]+=above;
            }
        }
    }
    for(i=0;i<n;i++)if(a[i][m-1]>Max && b[0][i]==1) Max=a[i][m-1];
    for(i=0;i<m;i++)if(a[n-1][i]>Max && b[1][i]==1) Max=a[n-1][i];
    
    if(Max==-1 || Max==-2) cout<<"cannot arrive.";
    else cout<<Max;
    return 0;
}
/*赛题题目:SY学语文
所属比赛:第一届无聊的四十五中模拟赛
问题编号:396 [提交该赛题]
描述: 背景
SY学习了苏轼的《江城子》后，大为震撼。“左牵黄，右擎苍”！啊，多么豪迈！SY于是也骑着骡子，来到了一片旷野……
描述
旷野是n*m的长方形的。SY刚开始在左上角的(1,1)点。他想跨越这个旷野，必须要走到最下边，或是最右边。而骡子是走马步的（但不蹩马腿），但它只愿意往右下边走（也就是说，如果骡子在(x,y)点，那么下一步它只能走到(x+1,y+2)或(x+2,y+1)）。
每个点不是有石头，就是有花。有石头的点不能到达。花的枝数一定是正整数。SY每到一点，就会拣起那一点的花。他想在离开旷野之前捡起最多的花（(1,1)点要捡。离开旷野时，即在最下边或最右边也可以捡）。 
输入格式: 第一行两个数，n,m（1<=n,m<=1000）。
以下是n行，每行m个数，表示这个旷野。若此点有花，则是花的枝数(1~100)，否则（即是石头）是-1。 
输出格式: 一个数，捡的最多的花数。如果不能离开旷野，即不能到达最下边或最右边，则输出“cannot arrive.” 
输入文件: 直接输入即可 
输出文件: 直接输出即可 注意,不要在最后输出空行或空格! 
样例输入: 5 4
2 3 -1 4
1 1 -1 2
-1 5 1 3
2 4 3 3
1 2 2 1 
样例输出: 10
{解释：(1,1)→(3,2)→(4,4)} 
*/
